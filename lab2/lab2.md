# Lab2挑战———2110697段钧淇

## 扩展练习Challenge1：buddy system（伙伴系统）分配算法（需要编程）
Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…

参考伙伴分配器的一个极简实现， 在ucore中实现buddy system分配算法，要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

### 设计思路

参考《伙伴分配器的一个极简实现》，我的Buddy System 内存管理算法的实现思路如下：

- 将一块连续的物理内存划分为多个大小不同的块。这些块的大小通常是2的幂次方，例如1页、2页、4页等。可以通过位运算来计算每个块的大小。

- 创建一个二叉树用于管理这些内存块。树的根节点代表整个可用内存区域，每个节点表示一个内存块。如果一个节点被分配出去，则它的两个子节点表示已分配的块。如果一个节点的两个子节点都没有被分配，则该节点可以与其兄弟节点合并为一个更大的块。

- 初始化内存管理器。在初始化过程中，需要计算可管理的最大内存区域，并为每个节点初始化记录最长空闲页数的数组。

- 分配内存。当需要分配一定数量的页面时，从根节点开始遍历二叉树，找到第一个满足分配条件的节点。具体的分配策略有很多种，可以选择首次适配、最佳适配或最差适配等。

- 当分配成功后，将该节点标记为已分配状态，并更新其父节点及上层节点的最长空闲页数。

- 释放内存。释放内存时，需要找到对应的节点，并将其标记为未分配状态。如果该节点的两个子节点都是未分配状态，则可以合并为一个更大的块，继续向上检查是否可以进一步合并。

- 更新最长空闲页数。在释放内存后，需要更新受影响的节点及其父节点的最长空闲页数，以更新整个二叉树的状态。

- 通过统计最长空闲页数来获取可用的空闲页数量。

算法中关键函数如下：

#### `buddy_init_memmap`
`buddy_init_memmap`函数在物理内存映射初始化后被调用，用于初始化 Buddy System 的全局变量。函数中包括以下几个步骤：

 * 计算可管理的最大内存区域。
 * 初始化记录每个节点最长空闲页数的数组 bubby_longest。
 *  将存储 bubby_longest 的页面设置为保留状态。
 * 将非保留页面全部设置为分配失败的状态。

#### `buddy_alloc_pages`
`buddy_alloc_pages`函数用于分配指定数量的页面。函数中包括以下几个步骤：
 * =确保传入的页面数量是2的幂次方，如果不是，则修正为最近的2的幂次方。
 * 检查要分配的页面数量是否超过了最大可分配页面数量，如果超过则分配失败，返回NULL。
 * 根据节点大小和页面数量，从树的顶部开始找到合适的位置进行分配。
 * 从根节点开始，根据左子叶节点和右子叶节点的最长空闲页数来确定分配的位置，直到找到符合条件的节点。
 * 将该节点下的所有页面标记为已分配状态，并更新父节点的最长空闲页数。
 * 返回新分配页面的起始地址。


#### `buddy_free_pages`
`buddy_free_pages`函数用于释放页面。函数中包括以下几个步骤：

 * 找到对应基地址的节点以及其大小。
 * 从该节点开始向上遍历，找到第一个最低的节点(即最近的叶节点)，该节点的最长空闲页数为0。
 * 将要释放的页面标记为非空闲状态，并将引用计数设置为0。
 * 更新该节点的最长空闲页数。
 * 如果存在相邻的兄弟节点都是空闲的，则将它们合并，并更新父节点的最长空闲页数。

 ### 测试
为了验证正确性，编写如下`buddy_check`函数测试：

```c
static void buddy_check(void) {
    int all_pages = nr_free_pages(); // 获取空闲页面数量

    struct Page* p0, *p1, *p2, *p3, *p4;

    // 分配页面测试
    assert(alloc_pages(all_pages + 1) == NULL); // 测试分配超过可用页面数量的情况

    p0 = alloc_pages(1); // 分配 1 页
    assert(p0 != NULL); // 断言分配成功

    p1 = alloc_pages(2); // 分配 2 页
    assert(p1 == p0 + 2); // 断言第一次分配与第二次分配间隔了两页
    assert(!PageReserved(p0) && !PageReserved(p1)); // 断言分配的物理页面不是保留页面
    assert(!PageProperty(p0) && !PageProperty(p1)); // 断言分配的物理页面不是属性页面

    p2 = alloc_pages(1); // 分配 1 页
    assert(p2 == p0 + 1); // 断言第三次分配和第一次分配之间隔了一个页面

    p3 = alloc_pages(2); // 分配 2 页
    assert(p3 == p0 + 4); // 断言第四次分配和第一次分配之间隔了四个页面
    assert(!PageProperty(p3) && !PageProperty(p3 + 1) && PageProperty(p3 + 2)); // 断言分配的物理页面的属性正确

    // 释放页面测试
    free_pages(p1, 2); // 释放两页
    assert(PageProperty(p1) && PageProperty(p1 + 1)); // 断言释放的物理页面被标记为属性页面
    assert(p1->ref == 0); // 断言引用计数为 0，即该页已被释放

    free_pages(p0, 1); // 释放一页
    free_pages(p2, 1); // 释放一页

    // 使用已释放的页面
    p4 = alloc_pages(2); // 再次分配 2 页，此时会使用之前释放的页面
    assert(p4 == p0); // 断言第五次分配得到了正确的地址

    free_pages(p4, 2); // 释放两页
    assert((*(p4 + 1)).ref == 0); // 断言第二个页面的引用计数为 0，即该页已被释放

    // 空闲页面数测试
    assert(nr_free_pages() == all_pages / 2); // 断言空闲页面数量为之前的一半

    free_pages(p3, 2); // 释放两页

    // 分配和释放多个页面
    p1 = alloc_pages(33); // 分配 33 页
    assert(p1 != NULL); // 断言分配成功

    free_pages(p1, 64); // 释放 64 页

    // 空闲页面数测试
    assert(nr_free_pages() == all_pages); // 断言空闲页面数量与初始数量相同
}
```
### 运行
需要给`kern/mm/pmm.c`加入头文件
```c
#include <buddy_pmm.h>
```
需要更改`kern/mm/pmm.c`中的

```c
pmm_manager = &default_pmm_manager;
```

为
```c
pmm_manager = &buddy_pmm_manager;
```
需要把`kern/mm/pmm.h`中这部分注释符号去掉，变成代码，用来将物理地址 pa 转换为对应的内核虚拟地址
```c
#define KADDR(pa)                                                \
    ({                                                           \
        uintptr_t __m_pa = (pa);                                 \
        size_t __m_ppn = PPN(__m_pa);                            \
        if (__m_ppn >= npage) {                                  \
            panic("KADDR called with invalid pa %08lx", __m_pa); \
        }                                                        \
        (void *)(__m_pa + va_pa_offset);                         \
    })
```
启动操作系统，显示如下：
```c
memory management: buddy_pmm_manager
physcial memory map:
  memory: 0x0000000007e00000, [0x0000000080200000, 0x0000000087ffffff].
BUDDY: 最大可管理页面数 = 16384，用于存储longest的页面数 = 33
check_alloc_page() succeeded!
```
## 扩展练习Challenge2：任意大小的内存单元slub分配算法（需要编程）
slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。

参考linux的slub分配算法/，在ucore中实现slub分配算法。要求有比较充分的测试用例说明实现的正确性，需要有设计文档。

 Slub 分配算法是非常复杂的，需要考虑缓存对齐、NUMA 等非常多的问题，在这里我`没有成功完成`，只能有部分思路和想法。

 以下是一个简化的实现思路：

- 第一层：基于页大小的内存分配
  - 初始化内存池：在系统初始化时，根据物理内存大小将整个物理内存划分为多个页（Page）。
  - 维护空闲页链表：将所有空闲的页组织成一个链表，以便后续分配使用。
  - 对象分配：当需要分配一个大于等于页大小的对象时，从空闲页链表中取出一个页，将其标记为已分配，并返回该页的起始地址作为对象的内存单元。
- 第二层：基于任意大小的内存分配
  - 初始化活动链表：根据对象大小范围，初始化一系列活动链表，每个链表对应一种对象大小。
  - 对象分配：当需要分配一个小于页大小的对象时，根据对象大小找到对应的活动链表。
  - 检索可用内存单元：从所选活动链表中检查是否有可用的内存单元。
内存单元分配：如果存在可用的内存单元，则将其分配给请求的对象，并更新相应的链表状态。
  - 内存不足的情况：如果所选活动链表中没有可用的内存单元，则回到第一层，从空闲页链表中取出一个页，将其标记为已分配，并返回该页的起始地址作为对象的内存单元。

以下是预想需要用到的数据结构：
- slab管理结构体：应该会需要一个slab管理结构体，用于跟踪和管理每个slab块的状态。可以命名为`slab_t`
- 表示缓存的结构体：应该需要表示一个缓存的结构体，需要包含了完整、部分和空闲slab的链表，对象的大小，对象的数量，构造函数和析构函数指针，缓存的名称以及在缓存链表中的链接。可以命名为`kmem_cache_t`

以下是我能想到的需要用到的关键函数：
- 创建一个缓存的函数。接收缓存的名称、对象的大小、构造函数和析构函数等参数，并返回一个指向缓存的指针。
- 销毁一个缓存的函数。接收一个指向缓存的指针，并释放相关资源。
- 从缓存中分配一个对象的函数。接收一个指向缓存的指针，并返回一个指向分配的对象的指针。
- 从缓存中分配一个对象并将其清零的函数。接收一个指向缓存的指针，并返回一个指向分配的对象的指针，同时使用memset函数将对象清零。
- 释放一个对象的函数。接收一个指向缓存的指针和一个指向要释放的对象的指针。
- 获取缓存对象大小的函数。接收一个指向缓存的指针，并返回缓存对象的大小。
- 获取缓存名称的函数。接收一个指向缓存的指针，并返回缓存的名称。
- 销毁缓存中的所有空闲slab的函数。接收一个指向缓存的指针，并释放所有空闲slab所占用的内存。
- 回收所有缓存的函数。遍历缓存链表，依次调用销毁缓存中的所有空闲slab的函数来销毁每个缓存中的空闲slab。
- 分配任意大小对象的函数。接收一个大小参数，并根据大小选择对应的缓存，然后调用从缓存中分配一个对象的函数来分配对象。
- 释放已分配对象的函数。接收一个指向要释放的对象的指针，并根据对象地址找到对应的缓存，然后调用释放一个对象的函数释放对象。
- 获取对象大小的函数。接收一个指向对象的指针，并返回对象的大小。
- 初始化内存管理模块的函数。

我努力地按照上面的思路和想法编程，但是`未能成功`。

## 扩展练习Challenge3：硬件的可用物理内存范围的获取方法（思考题）
- 使用BIOS或UEFI接口：操作系统可以通过调用BIOS或UEFI接口来获取硬件信息，包括可用的物理内存范围。这些接口通常提供了获取内存映射表（Memory Map）的方法，通过解析内存映射表可以获得可用的物理内存地址范围。

- 使用ACPI：ACPI（高级配置与电源管理接口）是一种标准的硬件接口，操作系统可以通过ACPI来获取硬件信息，包括可用的物理内存范围。ACPI规范定义了一组固定的数据结构和方法，可以通过解析这些数据结构来获取物理内存的信息。

- 使用EFI Memory Map：在使用EFI（可扩展固件接口）的系统中，操作系统可以通过EFI内存映射表（EFI Memory Map）来获取可用的物理内存范围。EFI Memory Map记录了系统中各个物理内存区域的起始地址、结束地址以及属性信息，操作系统可以读取并解析这些信息来获取可用的物理内存范围。

- 使用物理内存管理器：操作系统可以使用物理内存管理器（Physical Memory Manager）来管理系统的物理内存。物理内存管理器可以通过与硬件直接交互，查询可用的物理内存范围，并将这些信息提供给操作系统使用。

- 解析页表：在支持虚拟内存的系统中，操作系统可以通过解析页表来获取物理内存的使用情况。页表是一种数据结构，记录了虚拟内存地址和物理内存地址之间的映射关系。通过分析页表中的映射信息，可以确定哪些物理内存地址是可用的。
