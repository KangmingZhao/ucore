练习 1：

la sp, bootstacktop的作用：用于加载一个地址（bootstacktop的地址）到栈指针寄存器（sp）。这是为了设置初始的内核栈。
（设置内核的初始栈空间的作用是为了在进程从用户态切换到内核态时，为内核代码提供一个可用的栈空间。内核栈是进程私有的，每个进程都有一个单独的内核栈，大小一般为8KB或16KB，取决于体系结构和配置。内核栈的位置在内核的内存区域中，只有内核能够访问，用户进程无法访问3。如果没有设置内核的初始栈空间，那么进程在执行系统调用或中断时，就没有地方保存这些信息，可能会导致内存错误或数据丢失。因此，设置内核的初始栈空间是为了保证进程在内核态运行时的正常功能和安全性。

tail 指令的目的是跳转到 kern_init 函数并开始执行它。但是，它使用了 "尾递归调用"（tail call）的方式，这在汇编语言中是一种特殊的函数调用形式，它在调用结束后不会返回到原始的函数调用点，而是直接跳转到被调用函数的代码。

Challenge1：

一般完整的流程是这样的：
1、关中断（CPU不再响应更高级的中断
2、保存断点以便能回来。（一般是保存程序计数器pc）
3、引出（也就是大概是读取这个程序的入口地址，以便后面执行）中断执行程序（也就是我们要中断当前的，然后去执行的东西。
4、保存现场和关键字。
5、开中断（）
6、执行中断服务程序（此时可以并发响应其他中断）
7、关中断
8、恢复现场
9、开中断
10、中断返回。

在我们“只有麻雀骨架”的代码里，大概能实现这些基本功能：保存当前状态，跳转到终端执行程序，然后再跳转回来。

关于是否要保存所有的寄存器，虽然光是从代码上来看，这里的__alltraps应该是把所有寄存器都保存了，而且这么操作省事，在寄存器不多的情况下也没什么大碍，但是理论上只需要把关键的寄存器（如pc等）保存，然后当前程序使用并且赋值了的a0、t0之类的寄存器保存即可。

mov a0, sp这个是传递参数用的（a0寄存器就是干这事儿的）。把这个打包好的结构体发给trap函数。（这个打包好的结构体就叫tf拉。（tf.epc就是异常处理寄存器了）


Challenge2：

csrw sscratch, sp:#保存栈顶指针到sscratch。到时候恢复回来就靠这个了。执行完之后，把所有寄存器手牵手连着存到当前栈底部开始间隔寄存器大小的内存空间。

csrrw s0, sscratch, x0实现了把sscratch（也就是sp）的值存到s0里，再把x0的值存到sscratch里。这里x0是zero寄存器，用来把sscratch清零（这个不是主要目的），这里是要把sp经过sscratch之后存到s0里面，然后s0再保存到 uintptr_t sp;位


来看看没有恢复的csr寄存器：sbadaddr寄存器用于存储导致异常的地址。这里导致异常的东西我们的trap已经处理过了，没有必要再处理了也不用恢复原来的地址了。scause寄存器包含了导致异常或中断发生的原因代码。已经处理完了也没必要再恢复了。这些不用恢复是因为它们和恢复后的运行状态没有关系。但是这两个寄存器好歹是存了和异常相关的地址的，这里的store是要整个打包传给异常处理程序的。











