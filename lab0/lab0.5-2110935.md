## lab0.5


### 练习内容完成以及与助教的对比。

在一个终端利用make debug，另一个终端打开gdb连接上。再连接的时候加入参数-ex 'x/10i $pc'来展示接下来的十个指令。与助教的演示视频有所不同的是，我这里有的指令如下：
	
   0x1000:      auipc   t0,0x0

   0x1004:      addi    a2,t0,40
   
   0x1008:      csrr    a0,mhartid
   
   0x100c:      ld      a1,32(t0)
   
   0x1010:      ld      t0,24(t0)
   
   0x1014:      jr      t0
   
   0x1018:      unimp
   
   0x101a:      0x8000
   
   0x101c:      unimp
   
   0x101e:      unimp
   
   (此处省略意⭐义⭐不⭐明的unimp)
   
   0x1022:      0x8700  (后面回用上，所以单独再多看10条指令）
  
比助教的视频中多出来了一个指令0x1010:      ld      t0,24(t0)。

一直使用si执行到0x1014后，跳转到0x0000000080000000。

(在关于为什么怎么找到0x8000一脸懵逼的时候，刷群聊天记录刷到有大哥问过相同的问题了，群真是好东西。然而事实上)

为了猜测这个是干啥的，现在我要没si一步都使用info registers来看看所有寄存器的值。啥都没执行的时候，所有寄存器都是0。

执行完第1条后，t0变成了0x0000000000001000。原因是auipc的作用是把当前地址0x1000和立即数0x0相加。

执行完第2条后，a2变成了0x0000000000001028。这里是简单的立即数加法，0x1000+0x28(也就是10进制的40)

执行完第3条后，a0没有什么变化，还是0(ﾟДﾟ*)ﾉ。这里则是说明当前标号为0，也就是第一个的处理器核心

执行完第4条后，a1变成了0x87000000(⊙_⊙)？

执行完第5条后，t0变成了0x80000000(⊙_⊙)？这里我一直有个误会，我一直以为就上面那个东西是啥读到就是啥。事实上虽然上面那个在0x1018那里是unimp，但是事实上这里只是没有指令，不是没有数据。根据x/g 0x1018来查看内存内容，那里得到的是2147483648，也就是16进制的80000000。之前一直看到0x1018是unimp，我还以为是我的加减法出问题了，，在知道这个的情况下，在看第四条的0x1020，得到的是：2264924160，也就是16进制的87000000。这就非常nice了。


### 知识点列出
